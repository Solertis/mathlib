/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import category_theory.over
import category_theory.thin
import category_theory.limits.shapes.pullbacks
import category_theory.isomorphism_classes

/-!
## Subobjects in a category.

We define `subobject X` as the (isomorphism classes of) monomorphisms into `X`.
This is naturally a preorder.

When the ambient category has pullbacks, `subobject X` has an intersection operation,
and becomes a `semilattice_inf`.
-/

universes v u

noncomputable theory

namespace category_theory

variables {C : Type u} [category.{v} C]

/-- The category of monomorphisms into `X` is "thin", i.e. a preorder. -/
instance {X : C} (A B : { f : over X // mono f.hom }) : subsingleton (A ‚ü∂ B) :=
begin
  fsplit,
  rintros ‚ü®f, _, wf‚ü© ‚ü®g, _, wg‚ü©,
  dsimp at *, simp at wf wg, ext, dsimp,
  exact (@cancel_mono _ _ _ _ _ _ B.property _ _).mp (wf.trans (wg.symm)),
end

/--
We define the subobjects of `X` simply to be the isomorphism classes of monomorphisms into `X`.
See https://ncatlab.org/nlab/show/subobject

One could instead just take the monomorphisms directly: not much changes!
See https://mathoverflow.net/questions/184196/concise-definition-of-subobjects
However if we follow this route we only get a preorder, not a partial order,
which is less convenient for describing lattice properties.
-/
def subobject (X : C) := isomorphism_classes.obj (Cat.of { f : over X // mono f.hom })

namespace subobject

/-- Construct a subobject from an explicit monomorphism. -/
def mk {X Y : C} (f : X ‚ü∂ Y) [w : mono f] : subobject Y :=
quot.mk _ ‚ü®over.mk f, w‚ü©

instance (X : C) : inhabited (subobject X) := ‚ü®mk (ùüô _)‚ü©

/-- The underlying object of a subobject. -/
def X {X : C} (A : subobject X) : C :=
(isomorphism_classes.representative A).val.left

/-- The inclusion of a subobject into the ambient object. -/
def Œπ {X : C} (A : subobject X) : A.X ‚ü∂ X :=
(isomorphism_classes.representative A).val.hom

instance {X : C} (A : subobject X) : mono (Œπ A) :=
(isomorphism_classes.representative A).property

/-- The underlying object of the subobject constructed from an explicit monomorphism is isomorphic
to the original source object. -/
def mk_X_iso {X Y : C} (f : X ‚ü∂ Y) [w : mono f] : (mk f).X ‚âÖ X :=
(over.forget Y).map_iso
  ((full_subcategory_inclusion _).map_iso
  (@isomorphism_classes.mk_representative_iso (Cat.of { f : over Y // mono f.hom }) ‚ü®over.mk f, w‚ü©))

@[simp]
lemma mk_X_iso_hom_comm {X Y : C} (f : X ‚ü∂ Y) [w : mono f] :
  (mk_X_iso f).hom ‚â´ f = (mk f).Œπ :=
begin
  have h := ((full_subcategory_inclusion _).map_iso
    (@isomorphism_classes.mk_representative_iso (Cat.of { f : over Y // mono f.hom })
      ‚ü®over.mk f, w‚ü©)).hom.w,
  dsimp at h,
  simpa only [category.comp_id] using h,
end

@[simp]
lemma mk_X_iso_inv_comm {X Y : C} (f : X ‚ü∂ Y) [w : mono f] :
  (mk_X_iso f).inv ‚â´ (mk f).Œπ = f :=
by simp [iso.inv_comp_eq]

/--
The preorder on subobjects of `X` is `(A,f) ‚â§ (B,g)`
if there exists a morphism `h : A ‚ü∂ B` so `h ‚â´ g = f`.
(Such a morphism is unique if it exists; in a moment we upgrade this to a `partial_order`.)
-/
instance (X : C) : preorder (subobject X) :=
{ le := Œª A B,
  nonempty (isomorphism_classes.representative A ‚ü∂ isomorphism_classes.representative B),
  le_refl := Œª A, ‚ü®ùüô _‚ü©,
  le_trans := Œª A B C, by { rintro ‚ü®f‚ü©, rintro ‚ü®g‚ü©, exact ‚ü®f ‚â´ g‚ü©, }, }

/--
Construct an inequality in the preorder on subobjects from an explicit morphism.
-/
lemma le_of_hom {X : C} {A B : subobject X} (f : A.X ‚ü∂ B.X) (w : f ‚â´ B.Œπ = A.Œπ) : A ‚â§ B :=
nonempty.intro (over.hom_mk f w)

/-- Construct a morphism between the underlying objects from an inequality between subobjects. -/
def hom_of_le {X : C} {A B : subobject X} (h : A ‚â§ B) : A.X ‚ü∂ B.X :=
comma_morphism.left (nonempty.some h)

@[simp]
lemma hom_of_le_comm {X : C} {A B : subobject X} (h : A ‚â§ B) :
  subobject.hom_of_le h ‚â´ B.Œπ = A.Œπ :=
begin
  have := (nonempty.some h).w,
  simp only [functor.id_map, functor.const.obj_map] at this,
  dsimp at this,
  simp only [category.comp_id] at this,
  exact this,
end

instance (X : C) : partial_order (subobject X) :=
{ le_antisymm := Œª A B h‚ÇÅ h‚ÇÇ,
  begin
    induction A,
    swap, refl,
    rcases A with ‚ü®‚ü®A, ‚ü®‚ü©, f‚ü©, w‚ÇÅ‚ü©,
    induction B,
    swap, refl,
    rcases B with ‚ü®‚ü®B, ‚ü®‚ü©, g‚ü©, w‚ÇÇ‚ü©,
    dsimp at A f w‚ÇÅ B g w‚ÇÇ,
    resetI,
    apply quot.sound,
    fsplit,
    apply iso_of_both_ways,
    { fsplit,
      { exact (mk_X_iso f).inv ‚â´ hom_of_le h‚ÇÅ ‚â´ (mk_X_iso g).hom, },
      { exact ‚ü®‚ü®rfl‚ü©‚ü© },
      { dsimp,
        rw [category.comp_id, category.assoc, (mk_X_iso f).inv_comp_eq, category.assoc],
        erw [mk_X_iso_hom_comm, mk_X_iso_hom_comm, hom_of_le_comm], }, },
    { fsplit,
      { exact (mk_X_iso g).inv ‚â´ hom_of_le h‚ÇÇ ‚â´ (mk_X_iso f).hom, },
      { exact ‚ü®‚ü®rfl‚ü©‚ü© },
      { dsimp,
        rw [category.comp_id, category.assoc, (mk_X_iso g).inv_comp_eq, category.assoc],
        erw [mk_X_iso_hom_comm, mk_X_iso_hom_comm, hom_of_le_comm], }, },
  end,
  ..(by apply_instance : preorder (subobject X)) }

open category_theory.limits

section has_pullbacks
variables [has_pullbacks C] (W : C)

instance : has_inf (subobject W) :=
{ inf := Œª A B,
  @mk _ _ _ W (@pullback.fst _ _ _ _ _ A.Œπ B.Œπ _ ‚â´ A.Œπ) (mono_comp _ _) }

local attribute [instance] mono_comp

lemma le_inf (X Y Z : subobject W) (f : X ‚â§ Y) (g : X ‚â§ Z) : X ‚â§ Y ‚äì Z :=
le_of_hom (pullback.lift (hom_of_le f) (hom_of_le g) (by simp) ‚â´ (mk_X_iso _).inv)
  (by { slice_lhs 2 3 { erw mk_X_iso_inv_comm _, }, simp })

lemma inf_le_left (X Y : subobject W) : X ‚äì Y ‚â§ X :=
le_of_hom ((mk_X_iso _).hom ‚â´ pullback.fst) (by { simp, refl, })

lemma inf_le_right (X Y : subobject W) : X ‚äì Y ‚â§ Y :=
le_of_hom ((mk_X_iso _).hom ‚â´ pullback.snd)
  (by { rw [category.assoc, ‚Üêpullback.condition], simp, refl, })

instance : semilattice_inf (subobject W) :=
{ le_inf := le_inf W,
  inf_le_left := inf_le_left W,
  inf_le_right := inf_le_right W,
  ..(by apply_instance : partial_order (subobject W)),
  ..(by apply_instance : has_inf (subobject W)) }

end has_pullbacks

end subobject

end category_theory
