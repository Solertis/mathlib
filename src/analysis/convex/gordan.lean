import analysis.convex.cone
import topology.continuous_function.algebra
import topology.instances.real
import topology.sequences
import analysis.normed_space.basic


open set linear_map
open_locale big_operators classical

variables {E : Type*} [add_comm_group E] [module ℝ E]
  {F : Type*} [add_comm_group F] [module ℝ F]
  {G : Type*} [add_comm_group G] [module ℝ G]

def generate (S : set E) : convex_cone E :=
convex.to_cone _ (convex_convex_hull S)

lemma finset.center_mass_smul_left (k : ℝ) (ι : Type*)
  (hk : k ≠ 0) (t : finset ι) (w : ι → ℝ) (z : ι → E) :
  t.center_mass (λ (i : ι), k * w i) z = t.center_mass w z :=
begin
  simp_rw [finset.center_mass, ←finset.mul_sum, mul_inv', mul_smul, ←finset.smul_sum, smul_smul,
    mul_comm _ k, inv_mul_cancel_left' hk],
end

lemma {u} mem_generate (s : set E) (x : E) :
  x ∈ generate s ↔
    ∃ (ι : Type u) (t : finset ι) (w : ι → ℝ) (z : ι → E) (ht : ∀ i ∈ t, 0 ≤ w i)
      (hw : 0 < t.sum w) (hz : ∀ i ∈ t, z i ∈ s), ∑ i in t, w i • z i = x :=
begin
  simp only [generate, convex.mem_to_cone', convex_hull_eq.{u}, exists_prop, gt_iff_lt,
    mem_set_of_eq, exists_and_distrib_left],
  split,
  { rintro ⟨k, hk, ι, t, w, z, hz, ht, hw, hx⟩,
    refine ⟨ι, t, λ i, k⁻¹ * w i, z, hz, _, λ i hi, mul_nonneg (inv_nonneg.2 hk.le) (hw i hi), _⟩,
    { rwa [←finset.mul_sum, ht, mul_one, inv_pos] },
    { simp_rw [mul_smul, ←finset.smul_sum, ←finset.center_mass_eq_of_sum_1 _ _ ht, hx, smul_smul],
      simp [hk.ne'] }},
  { rintro ⟨ι, t, w, z, hz, hw, ht, rfl⟩,
    refine ⟨(t.sum w)⁻¹, by rwa inv_pos, ι, t, λ i, (t.sum w)⁻¹ * w i, z, hz, _, _, _⟩,
    { rw [←finset.mul_sum, inv_mul_cancel],
      apply hw.ne' },
    { intros i hi,
      apply mul_nonneg _ (ht i hi),
      rw inv_nonneg,
      apply hw.le },
    rw finset.center_mass_smul_left,
    rw finset.center_mass,
    apply inv_ne_zero,
    apply hw.ne' }
end

variables {n : ℕ}

-- Given finitely many points of ℚ^n, say the convex cone they generate is C. Then C ∩ ℤ^n is
-- a submonoid of ℤ^n generated by finitely many points

-- Suffices to show:

-- Given finitely many points of ℤ^n, say the convex cone they generate is C. Then C ∩ ℤ^n is
-- a submonoid of ℤ^n generated by finitely many points

def is_rational (x : ℝ) := ∃ (q : ℚ), x = q
def is_integer (x : ℝ) := ∃ (z : ℤ), x = z

lemma exists_scaling {x : ℝ} (hx : is_rational x) :
  ∃ (n : ℕ), is_integer (n • x) :=
begin
  rcases hx with ⟨q, rfl⟩,
  refine ⟨q.denom, q.num, _⟩,
  simp only [nsmul_eq_mul],
  norm_cast,
  rw mul_comm,
  apply rat.mul_denom_eq_num,
end

lemma exists_scalings {ι : Type} {s : finset ι} (v : ι → ℝ) (hx : ∀ i ∈ s, is_rational (v i)) :
  ∃ (n : ℕ), 0 < n ∧ ∀ i ∈ s, is_integer (n • v i) :=
begin
  revert hx,
  apply finset.induction_on s,
  { exact λ _, ⟨1, by norm_num, by simp⟩, },
  { rintro x s hx ih hs,
    obtain ⟨m, hm₁, hm₂⟩ := ih (λ i hi, hs i (by simp [hi])),
    obtain ⟨q, hq⟩ := hs x (by simp),
    refine ⟨m * q.denom, mul_pos hm₁ q.pos, _⟩,
    simp only [forall_eq_or_imp, nsmul_eq_mul, finset.mem_insert, nat.cast_mul],
    refine ⟨⟨m * q.num, _⟩, _⟩,
    { push_cast,
      rw mul_assoc,
      rw hq,
      norm_cast,
      rw mul_comm (q.denom : ℚ),
      rw rat.mul_denom_eq_num,
      norm_cast },
    intros x hx,
    obtain ⟨z, hz⟩ := hm₂ x hx,
    rw mul_right_comm,
    refine ⟨z * q.denom, _⟩,
    push_cast,
    rw ←hz,
    simp }
end

def is_rational_point (x : fin n → ℝ) := ∀ i, is_rational (x i)
def is_integer_point (x : fin n → ℝ) := ∀ i, is_integer (x i)

def point_exists_scaling {x : fin n → ℝ} (hx : is_rational_point x) :
  ∃ (n : ℕ), 0 < n ∧ is_integer_point ((n : ℝ) • x) :=
let ⟨m, hm₁, hm₂⟩ := exists_scalings x (λ i (hi : _ ∈ finset.univ), hx i)
 in ⟨m, hm₁, λ i, by simpa using hm₂ i⟩

lemma is_rational_of_is_integer {x : ℝ} : is_integer x → is_rational x :=
λ ⟨z, hz⟩, ⟨z, by simp [hz]⟩

lemma is_rational_point_of_is_integer_point {x : fin n → ℝ} :
  is_integer_point x → is_rational_point x :=
λ h i, is_rational_of_is_integer (h _)

-- def make_integer (x : ℝ) (hx : is_integer_point x) : fin n → ℤ :=
-- begin
-- end

noncomputable def to_integer_point (x : fin n → ℝ) : fin n → ℤ := λ i, floor (x i)
lemma to_integer_point_eq {x : fin n → ℝ} (hx : is_integer_point x) (i) :
  (to_integer_point x i : ℝ) = x i :=
begin
  simp [to_integer_point],
  obtain ⟨z, hz⟩ := hx i,
  rw hz,
  simp
end

/-- `C` is an integral cone if it is a convex cone generated by finitely many integer points. -/
def is_integral_cone (C : set (fin n → ℝ)) : Prop :=
∃ (ι : Type) (s : finset ι) (w : ι → fin n → ℝ),
  (∀ i ∈ s, is_integer_point (w i)) ∧ C = generate (w '' s)

/-- `C` is an rational cone if it is a convex cone generated by finitely many rational points. -/
def is_rational_cone (C : set (fin n → ℝ)) : Prop :=
∃ (ι : Type) (s : finset ι) (w : ι → fin n → ℝ),
  (∀ i ∈ s, is_rational_point (w i)) ∧ C = generate (w '' s)

lemma is_integral_cone_iff_is_rational_cone (C : set (fin n → ℝ)) :
  is_integral_cone C ↔ is_rational_cone C :=
begin
  split,
  { rintro ⟨ι, s, w, hw₁, rfl⟩,
    refine ⟨ι, s, w, λ i hi, is_rational_point_of_is_integer_point (hw₁ _ hi), rfl⟩ },
  { rintro ⟨ι, s, w, hw₁, rfl⟩,
    have : ∀ i ∈ s, ∃ (m : ℕ), 0 < m ∧ is_integer_point ((m : ℝ) • w i),
    { intros i hi,
      apply point_exists_scaling (hw₁ i hi) },
    choose m hm₁ hm₂ using this,
    refine ⟨ι, s, λ i, if hi : i ∈ s then (m i hi : ℝ) • w i else 0, _, _⟩,
    { intros i hi,
      rw dif_pos hi,
      apply hm₂ },
    { rw convex_cone.ext'_iff,
      apply le_antisymm,
      { apply (convex_hull_to_cone_is_least _).2 _,
        simp only [mem_set_of_eq, image_subset_iff],
        rintro x (hx : x ∈ s),
        change w _ ∈ _,
        simp only [convex_cone.mem_coe],
        rw [generate, convex.mem_to_cone'],
        refine ⟨m x hx, by simpa using hm₁ x hx, subset_convex_hull _ _⟩,
        simp only [mem_image, finset.mem_coe],
        refine ⟨x, hx, _⟩,
        simp [hx] },
      { apply (convex_hull_to_cone_is_least _).2 _,
        simp only [mem_set_of_eq, image_subset_iff],
        rintro x (hx : x ∈ s),
        simp only [mem_preimage, convex_cone.mem_coe],
        rw [dif_pos hx, generate, convex.mem_to_cone'],
        refine ⟨(m x hx : ℝ)⁻¹, by simpa using hm₁ x hx, subset_convex_hull _ _⟩,
        simp only [mem_image, finset.mem_coe],
        refine ⟨x, hx, _⟩,
        rw smul_smul,
        rw inv_mul_cancel,
        simp only [one_smul],
        norm_cast,
        apply (hm₁ x hx).ne' } } }
end

def integral_restrict (C : add_submonoid (fin n → ℝ)) : add_submonoid (fin n → ℤ) :=
{ carrier := {x | (λ i, x i : fin n → ℝ) ∈ C},
  zero_mem' := C.zero_mem,
  add_mem' :=
  begin
    intros a b ha hb,
    simp only [int.cast_add, pi.add_apply, mem_set_of_eq],
    convert C.add_mem ha hb,
  end }

def box (ι : Type) : set (ι → ℝ) := {x | ∀ i, x i ∈ Icc (0:ℝ) 1}

lemma box_compact {ι : Type*} : is_compact (box ι) :=
compact_pi_infinite (λ i, compact_Icc)

noncomputable def evaluation {ι : Type*} (i : ι) : C((ι → ℝ), ℝ) :=
{ to_fun := λ f, f i }

noncomputable def smul_left (x : fin n → ℝ) : C(ℝ, fin n → ℝ) :=
{ to_fun := λ i, i • x,
  continuous_to_fun := continuous.smul (by continuity) (by continuity) }

-- lemma sum_continuous_hom {α β γ : Type*} [topological_space β] [topological_space γ] (s : finset α)
--   (f : α → C(β, γ)) : ∑ i in s, f i = ∑ i in s, f i :=
-- begin
-- end

lemma discrete_topology_of_points_open {α : Type*} [topological_space α]
  (h : ∀ x, is_open ({x} : set α)) : discrete_topology α :=
begin
  constructor,
  apply eq_bot_of_singletons_open h,
end

def is_discrete_set {α : Type*} [topological_space α] (s : set α) : Prop :=
discrete_topology s

lemma is_discrete_set_of_subset {α : Type*} [topological_space α] {s t : set α}
  (hs : is_discrete_set s) (ht : t ⊆ s) :
  is_discrete_set t :=
begin
  rw [is_discrete_set, ←forall_open_iff_discrete] at hs ⊢,
  intro q,
  obtain ⟨w, hw₁ : is_open _, hw₂⟩ := hs ((λ (x : t), ⟨x, ht x.prop⟩) '' q),
  refine ⟨w, hw₁, _⟩,
  ext ⟨x, hx⟩,
  simp only [mem_preimage, subtype.coe_mk],
  rw set.ext_iff at hw₂,
  simpa [hx] using hw₂ ⟨x, ht hx⟩,
end

lemma integer_lattice_discrete : is_discrete_set {x : fin n → ℝ | is_integer_point x} :=
begin
  apply discrete_topology_of_points_open,
  rintro ⟨x, hx⟩,
  rw is_open_induced_eq,
  simp only [mem_image, mem_set_of_eq],
  refine ⟨metric.ball x 1, metric.is_open_ball, _⟩,
  ext ⟨y, hy⟩,
  simp only [metric.mem_ball, mem_singleton_iff, subtype.mk_eq_mk, mem_preimage, subtype.coe_mk],
  rw dist_pi_lt_iff (show (0 : ℝ) < 1, by norm_num),
  split,
  { intro h,
    ext i,
    specialize h i,
    rcases hx i with ⟨x', hx'⟩,
    rcases hy i with ⟨y', hy'⟩,
    rw [hx', hy'] at h ⊢,
    rw real.dist_eq at h,
    norm_cast at h,
    simp only [int.eq_zero_iff_abs_lt_one, sub_eq_zero] at h,
    rw h },
  { rintro rfl,
    simp [zero_lt_one] },
end

lemma integer_points_eq_prod :
  {x : fin n → ℝ | is_integer_point x} = set.pi univ (λ _, {x : ℝ | is_integer x}) :=
begin
  ext,
  simp [is_integer_point],
end

lemma integers_closed : is_closed {x : ℝ | ∃ (z : ℤ), x = z} :=
begin
  rw ←is_open_compl_iff,
  have : {x : ℝ | ∃ (z : ℤ), x = z}ᶜ = ⋃ (z : ℤ), Ioo z (z+1),
  { ext,
    simp only [not_exists, mem_Union, mem_Ioo, mem_set_of_eq, mem_compl_eq],
    split,
    { intro q,
      refine ⟨floor x, lt_of_le_of_ne (floor_le x) (ne.symm (q _)), _⟩,
      apply lt_floor_add_one },
    { rintro ⟨z, hz₁, hz₂⟩ y rfl,
      norm_cast at hz₁ hz₂,
      linarith } },
  rw this,
  exact is_open_Union (λ i, is_open_Ioo),
end

lemma integer_lattice_closed : is_closed {x : fin n → ℝ | is_integer_point x} :=
begin
  rw integer_points_eq_prod,
  apply is_closed_set_pi,
  rintro i -,
  simp_rw is_integer,
  apply integers_closed
end

-- lemma compact_preimage {α β : Type*} (s t : set α) (hs : is_compact s) (is_closed t)
theorem gordan {C : add_submonoid (fin n → ℝ)} (hC : is_rational_cone (C : set (fin n → ℝ))) :
  ∃ (s : finset (fin n → ℤ)), integral_restrict C = add_submonoid.closure (s : set (fin n → ℤ)) :=
begin
  rw ←is_integral_cone_iff_is_rational_cone at hC,
  rcases hC with ⟨ι, s, w, hw₁, hw₂⟩,
  let B := {x : fin n → ℝ |
                ∃ w' : ι → ℝ, (∀ (i ∈ s), w' i ∈ set.Ico (0:ℝ) 1) ∧
                ∑ i in s, w' i • w i = x},
  let B' := {x : fin n → ℝ |
                ∃ w' : ι → ℝ, (∀ (i ∈ s), w' i ∈ set.Icc (0:ℝ) 1) ∧
                ∑ i in s, w' i • w i = x},
  have : B ⊆ B',
  { rintro x ⟨w, hw₁, hw₂⟩,
    refine ⟨w, λ i hi, Ico_subset_Icc_self (hw₁ i hi), hw₂⟩ },
  let f : C((s : set ι) → ℝ, fin n → ℝ) :=
    ∑ (i : (s : set ι)), (smul_left (w i)).comp (evaluation i),
  have : f '' box _ = B',
  { ext,
    simp only [mem_image, continuous_map.coe_sum, continuous_map.comp_coe, fintype.sum_apply,
      mem_set_of_eq, function.comp_app, smul_left, evaluation, continuous_map.coe_mk, box,
      ←finset.sum_finset_coe _ s],
    split,
    { rintro ⟨w, hw₁, rfl⟩,
      refine ⟨λ i, if hi : i ∈ s then w ⟨i, hi⟩ else 0, _, _⟩,
      { intros i hi,
        simp only [hi, dif_pos],
        apply hw₁ },
      { apply finset.sum_congr rfl,
        simp } },
    { rintro ⟨w, hw, rfl⟩,
      exact ⟨λ i, w i, λ i, hw _ i.prop, rfl⟩ } },
  have : is_compact B',
  { rw ←this,
    apply is_compact.image,
    refine compact_pi_infinite (λ i, compact_Icc),
    apply f.continuous },
  let BL := B ∩ {x | is_integer_point x},
  let B'L := B' ∩ {x | is_integer_point x},
  have : is_compact B'L := ‹is_compact B'›.inter_right integer_lattice_closed,
  have : compact_space B'L,
  { rwa ←compact_iff_compact_space },
  have : discrete_topology ↥B'L,
  { change is_discrete_set B'L,
    apply is_discrete_set_of_subset _ (inter_subset_right _ _),
    apply integer_lattice_discrete },
  resetI,
  haveI : fintype B'L := fintype_of_compact_of_discrete,
  have : set.finite BL := ⟨fintype_subset B'L (inter_subset_inter_left _ ‹B ⊆ B'›)⟩,
  let t : set (fin n → ℤ) := (λ x i, (x i : ℝ)) ⁻¹' BL,
  have : set.finite t,
  { apply finite.preimage _ this,
    intros x hx y hy q,
    ext i,
    rw function.funext_iff at q,
    specialize q i,
    simpa using q },
  let s' : finset (fin n → ℤ) := (s.image w).image to_integer_point,
  refine ⟨‹t.finite›.to_finset ∪ s', _⟩,
  apply le_antisymm,
  { sorry },
  { rw add_submonoid.closure_le,
    intros x hx,
    simp only [mem_image, finset.coe_union, finite.coe_to_finset, mem_inter_eq, mem_union_eq,
      mem_set_of_eq, mem_preimage, finset.mem_coe, finset.coe_image] at hx,
    rcases hx with (⟨⟨w', hw', hw''⟩, -⟩ | _),
    { simp only [set_like.mem_coe],
      rw integral_restrict,
    }
    -- simp only [finset.mem_coe, finite.coe_to_finset, finset.coe_image, finset.mem_union] at hx,
  --   simp only [mem_image, finset.coe_union, finite.coe_to_finset, mem_inter_eq, mem_union_eq, mem_set_of_eq,
  -- exists_exists_and_eq_and, mem_preimage, set_like.mem_coe, mem_Ico, finset.mem_coe, finset.coe_image] at hx ⊢,


  }
  -- apply add_submonoid.antisymm,


  -- let f : ((s : set ι) → ℝ) → fin n → ℝ := λ w', ∑ (i : (s : set ι)), w' i • w i,
  -- have : continuous f,

end

-- theorem gordan_int (t : finset (fin n → ℤ)) :
--   ∃ (s : finset (fin n → ℤ)), convex.to_cone _ (convex_convex_hull t) = _ :=
-- begin
-- end

-- def is_affine_monoid (S : add_submonoid (fin n → ℤ)) : Prop :=
-- ∃ (ι : Type) (t : finset ι) (v : ι → fin n → ℤ),
--   (∀ i ∈ t, v i ∈ S) ∧ add_submonoid.closure (v '' t) = S

-- def is_integral_over (S : add_submonoid (fin n → ℤ)) (x : fin n → ℤ) : Prop := ∃ (c : ℕ), c • x ∈ S
-- def integral_closure (S : add_submonoid (fin n → ℤ)) : add_submonoid (fin n → ℤ) :=
-- { carrier := { x | is_integral_over S x },
--   zero_mem' := ⟨0, by simp [S.zero_mem]⟩,
--   add_mem' :=
--   begin
--     rintro a b ⟨n₁, hn₁⟩ ⟨n₂, hn₂⟩,
--     refine ⟨_, _⟩,

--   end

-- }

-- def
