import analysis.convex.cone
import topology.continuous_function.algebra
import topology.instances.real_vector_space
import analysis.normed_space.basic

open set linear_map
open_locale big_operators classical

variables {E : Type*} [add_comm_group E] [module ℝ E]
  {F : Type*} [add_comm_group F] [module ℝ F]
  {G : Type*} [add_comm_group G] [module ℝ G]

def finitely_generate (S : finset E) : convex_cone E :=
convex.to_cone _ (convex_convex_hull S)

variables {n : ℕ}

-- Given finitely many points of ℚ^n, say the convex cone they generate is C. Then C ∩ ℤ^n is
-- a submonoid of ℤ^n generated by finitely many points

-- Suffices to show:

-- Given finitely many points of ℤ^n, say the convex cone they generate is C. Then C ∩ ℤ^n is
-- a submonoid of ℤ^n generated by finitely many points

def is_rational (x : ℝ) := ∃ (q : ℚ), x = q
def is_integer (x : ℝ) := ∃ (z : ℤ), x = z

lemma exists_scaling {x : ℝ} (hx : is_rational x) :
  ∃ (n : ℕ), is_integer (n • x) :=
begin
  rcases hx with ⟨q, rfl⟩,
  refine ⟨q.denom, q.num, _⟩,
  simp only [nsmul_eq_mul],
  norm_cast,
  rw mul_comm,
  apply rat.mul_denom_eq_num,
end

lemma exists_scalings {s : finset ℝ} (hx : ∀ i ∈ s, is_rational i) :
  ∃ (n : ℕ), 0 < n ∧ ∀ i ∈ s, is_integer (n • i) :=
begin
  revert hx,
  apply finset.induction_on s,
  { exact λ _, ⟨1, by norm_num, by simp⟩, },
  { rintro x s hx ih hs,
    obtain ⟨m, hm₁, hm₂⟩ := ih (λ i hi, hs i (by simp [hi])),
    obtain ⟨q, rfl⟩ := hs x (by simp),
    refine ⟨m * q.denom, mul_pos hm₁ q.pos, _⟩,
    simp only [forall_eq_or_imp, nsmul_eq_mul, finset.mem_insert, nat.cast_mul],
    refine ⟨⟨m * q.num, _⟩, _⟩,
    { push_cast,
      rw mul_assoc,
      norm_cast,
      rw mul_comm (q.denom : ℚ),
      rw rat.mul_denom_eq_num,
      norm_cast },
    intros x hx,
    obtain ⟨z, hz⟩ := hm₂ x hx,
    rw mul_right_comm,
    refine ⟨z * q.denom, _⟩,
    push_cast,
    rw ←hz,
    simp }
end

def is_rational_point (x : fin n → ℝ) := ∀ i, is_rational (x i)
def is_integer_point (x : fin n → ℝ) := ∀ i, is_integer (x i)

lemma is_rational_of_is_integer {x : ℝ} : is_integer x → is_rational x :=
λ ⟨z, hz⟩, ⟨z, by simp [hz]⟩

lemma is_rational_point_of_is_integer_point {x : fin n → ℝ} :
  is_integer_point x → is_rational_point x :=
λ h i, is_rational_of_is_integer (h _)

/-- `C` is an integral cone if it is a convex cone generated by finitely many integer points. -/
def is_integral_cone (C : set (fin n → ℝ)) : Prop :=
∃ (ι : Type) (s : finset ι) (w : ι → fin n → ℝ),
  (∀ i ∈ s, is_integer_point (w i)) ∧ C = convex.to_cone _ (convex_convex_hull (w '' s))

/-- `C` is an rational cone if it is a convex cone generated by finitely many rational points. -/
def is_rational_cone (C : set (fin n → ℝ)) : Prop :=
∃ (ι : Type) (s : finset ι) (w : ι → fin n → ℝ),
  (∀ i ∈ s, is_rational_point (w i)) ∧ C = convex.to_cone _ (convex_convex_hull (w '' s))

lemma is_integral_cone_iff_is_rational_cone (C : set (fin n → ℝ)) :
  is_integral_cone C ↔ is_rational_cone C :=
begin
  split,
  { rintro ⟨ι, s, w, hw₁, rfl⟩,
    refine ⟨ι, s, w, λ i hi, is_rational_point_of_is_integer_point (hw₁ _ hi), rfl⟩ },
  { rintro ⟨ι, s, w, hw₁, rfl⟩,
    sorry } -- scale up all your points so they're integers
end

def integral_restrict (C : add_submonoid (fin n → ℝ)) : add_submonoid (fin n → ℤ) :=
{ carrier := {x | (λ i, x i : fin n → ℝ) ∈ C},
  zero_mem' := C.zero_mem,
  add_mem' :=
  begin
    intros a b ha hb,
    simp only [int.cast_add, pi.add_apply, mem_set_of_eq],
    convert C.add_mem ha hb,
  end }

def box (ι : Type) : set (ι → ℝ) := {x | ∀ i, x i ∈ Icc (0:ℝ) 1}

lemma box_compact {ι : Type*} : is_compact (box ι) :=
compact_pi_infinite (λ i, compact_Icc)

noncomputable def evaluation {ι : Type*} (i : ι) : C((ι → ℝ), ℝ) :=
{ to_fun := λ f, f i }

noncomputable def smul_left (x : fin n → ℝ) : C(ℝ, fin n → ℝ) :=
{ to_fun := λ i, i • x,
  continuous_to_fun := continuous.smul (by continuity) (by continuity) }

-- lemma sum_continuous_hom {α β γ : Type*} [topological_space β] [topological_space γ] (s : finset α)
--   (f : α → C(β, γ)) : ∑ i in s, f i = ∑ i in s, f i :=
-- begin
-- end

lemma integer_lattice_closed : is_closed {x : fin n → ℝ | is_integer_point x} :=
sorry

theorem gordan {C : add_submonoid (fin n → ℝ)} (hC : is_rational_cone (C : set (fin n → ℝ))) :
  ∃ (s : finset (fin n → ℤ)), integral_restrict C = add_submonoid.closure (s : set (fin n → ℤ)) :=
begin
  rw ←is_integral_cone_iff_is_rational_cone at hC,
  rcases hC with ⟨ι, s, w, hw₁, hw₂⟩,
  let B := {x : fin n → ℝ |
                ∃ w' : ι → ℝ, (∀ (i ∈ s), w' i ∈ set.Ico (0:ℝ) 1) ∧
                ∑ i in s, w' i • w i = x},
  let B' := {x : fin n → ℝ |
                ∃ w' : ι → ℝ, (∀ (i ∈ s), w' i ∈ set.Icc (0:ℝ) 1) ∧
                ∑ i in s, w' i • w i = x},
  let f : C((s : set ι) → ℝ, fin n → ℝ) :=
    ∑ (i : (s : set ι)), (smul_left (w i)).comp (evaluation i),
  have : f '' box _ = B',
  { ext,
    simp only [mem_image, continuous_map.coe_sum, continuous_map.comp_coe, fintype.sum_apply,
      mem_set_of_eq, function.comp_app, smul_left, evaluation, continuous_map.coe_mk, box,
      ←finset.sum_finset_coe _ s],
    split,
    { rintro ⟨w, hw₁, rfl⟩,
      refine ⟨λ i, if hi : i ∈ s then w ⟨i, hi⟩ else 0, _, _⟩,
      { intros i hi,
        simp only [hi, dif_pos],
        apply hw₁ },
      { apply finset.sum_congr rfl,
        simp } },
    { rintro ⟨w, hw, rfl⟩,
      exact ⟨λ i, w i, λ i, hw _ i.prop, rfl⟩ } },
  have : is_compact B',
  { rw ←this,
    apply is_compact.image,
    refine compact_pi_infinite (λ i, compact_Icc),
    apply f.continuous },
  let BL := B ∩ {x | is_integer_point x},
  let B'L := B' ∩ {x | is_integer_point x},
  have : is_compact B'L := ‹is_compact B'›.inter_right integer_lattice_closed,
  have : compact_space B'L,
  { rwa ←compact_iff_compact_space },
  have : discrete_topology ↥B'L,
  {

  },
  resetI,
  have : fintype B'L := fintype_of_compact_of_discrete,
  -- let f : ((s : set ι) → ℝ) → fin n → ℝ := λ w', ∑ (i : (s : set ι)), w' i • w i,
  -- have : continuous f,
  -- {

  -- }

end

-- theorem gordan_int (t : finset (fin n → ℤ)) :
--   ∃ (s : finset (fin n → ℤ)), convex.to_cone _ (convex_convex_hull t) = _ :=
-- begin
-- end

-- def is_affine_monoid (S : add_submonoid (fin n → ℤ)) : Prop :=
-- ∃ (ι : Type) (t : finset ι) (v : ι → fin n → ℤ),
--   (∀ i ∈ t, v i ∈ S) ∧ add_submonoid.closure (v '' t) = S

-- def is_integral_over (S : add_submonoid (fin n → ℤ)) (x : fin n → ℤ) : Prop := ∃ (c : ℕ), c • x ∈ S
-- def integral_closure (S : add_submonoid (fin n → ℤ)) : add_submonoid (fin n → ℤ) :=
-- { carrier := { x | is_integral_over S x },
--   zero_mem' := ⟨0, by simp [S.zero_mem]⟩,
--   add_mem' :=
--   begin
--     rintro a b ⟨n₁, hn₁⟩ ⟨n₂, hn₂⟩,
--     refine ⟨_, _⟩,

--   end

-- }

-- def
