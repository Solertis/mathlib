/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Michael Howes
-/
import group_theory.quotient_group
import tactic.group
import group_theory.perm.sign
import set_theory.cardinal
open subgroup

/-!
# The abelianization of a group

This file defines the commutator and the abelianization of a group. It furthermore prepares for the
result that the abelianization is left adjoint to the forgetful functor from abelian groups to
groups, which can be found in `algebra/category/Group/adjunctions`.

## Main definitions

* `commutator`: defines the commutator of a group `G` as a subgroup of `G`.
* `abelianization`: defines the abelianization of a group `G` as the quotient of a group by its
  commutator subgroup.
-/

universes u v

-- Let G be a group.
variables (G : Type u) [group G]

section commutator

/-- The commutator subgroup of a group G is the normal subgroup
  generated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹`. -/
@[derive subgroup.normal]
def commutator : subgroup G :=
normal_closure {x | ∃ p q, p * q * p⁻¹ * q⁻¹ = x}

end commutator

-- variables {G}

-- def general_commutator (H₁ : subgroup G) (H₂ : subgroup G) : subgroup G :=
-- subgroup.closure {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x}

-- instance general_commutator_normal (H₁ : subgroup G) (H₂ : subgroup G) [h₁ : H₁.normal]
--   [h₂ : H₂.normal] : normal (general_commutator H₁ H₂) :=
-- begin
--   let base : set G := {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x},
--   suffices h_base : base = group.conjugates_of_set base,
--   { dsimp only [general_commutator, ←base],
--     rw h_base,
--     exact subgroup.normal_closure_normal },
--   apply set.subset.antisymm group.subset_conjugates_of_set,
--   intros a h,
--   rw group.mem_conjugates_of_set_iff at h,
--   rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩,
--   exact ⟨d * c * d⁻¹, h₁.conj_mem c hc d, d * e * d⁻¹, h₂.conj_mem e he d, by group⟩,
-- end

-- lemma general_commutator_eq_normal_closure (H₁ : subgroup G) (H₂ : subgroup G) [H₁.normal]
--   [H₂.normal] : general_commutator H₁ H₂ = normal_closure (general_commutator H₁ H₂) :=
-- eq.symm (normal_closure_eq_self _)

-- lemma general_commutator_eq_normal_closure' (H₁ H₂ : subgroup G) [H₁.normal] [H₂.normal] :
--   general_commutator H₁ H₂ = normal_closure {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x} :=
-- by rw [general_commutator_eq_normal_closure, general_commutator,
--   normal_closure_closure_eq_normal_closure]

-- lemma general_commutator_mono {H₁ H₂ K₁ K₂ : subgroup G} (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) :
--   general_commutator H₁ H₂ ≤ general_commutator K₁ K₂ :=
-- begin
--   apply closure_mono,
--   rintros x ⟨p, hp, q, hq, rfl⟩,
--   exact ⟨p, h₁ hp, q, h₂ hq, rfl⟩,
-- end

-- section nth_commutator

-- variables (G)

-- def nth_commutator (n : ℕ) : subgroup G :=
-- nat.rec_on n (⊤ : subgroup G) (λ _ H, general_commutator H H)

-- lemma nth_commutator_normal (n : ℕ) : (nth_commutator G n).normal :=
-- begin
--   induction n with n ih,
--   { change (⊤ : subgroup G).normal,
--     exact subgroup.top_normal, },
--   { haveI : (nth_commutator G n).normal := ih,
--     change (general_commutator (nth_commutator G n) (nth_commutator G n)).normal,
--     exact general_commutator_normal (nth_commutator G n) (nth_commutator G n), }
-- end

-- lemma commutator_eq_general_commutator_top_top :
--   commutator G = general_commutator (⊤ : subgroup G) (⊤ : subgroup G) :=
-- begin
--   rw commutator,
--   rw general_commutator_eq_normal_closure',
--   apply le_antisymm; apply normal_closure_mono,
--   { exact λ x ⟨p, q, h⟩, ⟨p, mem_top p, q, mem_top q, h⟩, },
--   { exact λ x ⟨p, _, q, _, h⟩, ⟨p, q, h⟩, }
-- end

-- lemma commutator_def' : commutator G = subgroup.closure {x : G | ∃ p q, p * q * p⁻¹ * q⁻¹ = x} :=
-- begin
--   rw commutator_eq_general_commutator_top_top,
--   rw general_commutator,
--   apply le_antisymm; apply closure_mono,
--   { exact λ x ⟨p, _, q, _, h⟩, ⟨p, q, h⟩ },
--   { exact λ x ⟨p, q, h⟩, ⟨p, mem_top p, q, mem_top q, h⟩ }
-- end

-- @[simp] lemma nth_commutator_succ (n : ℕ) :
--   nth_commutator G (n + 1) = general_commutator (nth_commutator G n) (nth_commutator G n) := rfl

-- @[simp] lemma nth_commutator_zero : nth_commutator G 0 = ⊤ := rfl

-- @[simp] lemma nth_commutator_one : nth_commutator G 1 = commutator G :=
-- eq.symm $ commutator_eq_general_commutator_top_top G

-- end nth_commutator

-- section general_nth_commutator

-- variables {G} (H : subgroup G)

-- def general_nth_commutator (n : ℕ) : subgroup G :=
-- nat.rec_on n H (λ _ H, general_commutator H H)

-- lemma general_nth_commutator_succ (n : ℕ) : general_nth_commutator H (nat.succ n) =
--   general_commutator (general_nth_commutator H n) (general_nth_commutator H n) :=
-- rfl

-- lemma general_nth_commutator_zero : general_nth_commutator H 0 = H :=
-- rfl

-- lemma general_nth_commutator_one :
--   general_nth_commutator H 1 = general_commutator H H :=
-- by rw [general_nth_commutator_succ, general_nth_commutator_zero]

-- lemma additive_general_nth_commutator (n m : ℕ) :
--   general_nth_commutator H (n + m) = general_nth_commutator (general_nth_commutator H n) m :=
-- begin
--   induction m with m ih,
--   { simp only [general_nth_commutator_zero, add_zero], },
--   { simp only [general_nth_commutator_succ, ih], },
-- end

-- lemma additive_general_nth_commutator' (n m : ℕ) :
--   general_nth_commutator H (n + m) = general_nth_commutator (general_nth_commutator H m) n :=
-- begin
--   rw add_comm n m,
--   exact additive_general_nth_commutator H m n,
-- end

-- lemma general_nth_commutator_mono (K : subgroup G) (leq : H ≤ K) (n : ℕ) :
--   general_nth_commutator H n ≤ general_nth_commutator K n :=
-- begin
--   induction n with n ih,
--   { simp only [general_nth_commutator_zero, leq] },
--   { rw [general_nth_commutator_succ, general_nth_commutator_succ],
--     exact general_commutator_mono ih ih },
-- end

-- lemma nth_commutator_eq_general_nth_commutator_top :
--   nth_commutator G = general_nth_commutator ⊤ :=
-- begin
--   funext,
--   induction n with n ih,
--   { rw [nth_commutator_zero, general_nth_commutator_zero], },
--   { rw [nth_commutator_succ, general_nth_commutator_succ, ih], },
-- end

-- end general_nth_commutator

-- section commutator_map

-- variables {G} {G' : Type*} [group G'] {f : G →* G'}

-- lemma map_commutator_eq_commutator_map (H₁ H₂ : subgroup G) :
--   (general_commutator H₁ H₂).map f = general_commutator (H₁.map f) (H₂.map f) :=
-- begin
--   rw [general_commutator, general_commutator, monoid_hom.map_closure],
--   apply le_antisymm; apply closure_mono,
--   { rintros _ ⟨x, ⟨p, hp, q, hq, rfl⟩, rfl⟩,
--     refine ⟨f p, mem_map.mpr ⟨p, hp, rfl⟩, f q, mem_map.mpr ⟨q, hq, rfl⟩, by simp *⟩, },
--   { rintros x ⟨_, ⟨p, hp, rfl⟩, _, ⟨q, hq, rfl⟩, rfl⟩,
--     refine ⟨p * q * p⁻¹ * q⁻¹, ⟨p, hp, q, hq, rfl⟩, by simp *⟩, },
-- end

-- lemma lift_commutator_eq_commutator_lift_lift {H : subgroup G} (K₁ K₂ : subgroup H) :
--   (general_commutator K₁ K₂).lift = general_commutator (K₁.lift) (K₂.lift) :=
-- map_commutator_eq_commutator_map _ _

-- lemma commutator_le_commutator_map {H₁ H₂ : subgroup G} {K₁ K₂ : subgroup G'} (h₁ : K₁ ≤ H₁.map f)
--   (h₂ : K₂ ≤ H₂.map f) : general_commutator K₁ K₂ ≤ (general_commutator H₁ H₂).map f :=
-- begin
--   rw map_commutator_eq_commutator_map,
--   exact general_commutator_mono h₁ h₂,
-- end

-- section nth_commutator_map

-- variables (f)

-- lemma nth_commutator_map_le_nth_commutator (n : ℕ) :
--   (nth_commutator G n).map f ≤ nth_commutator G' n :=
-- begin
--   induction n with n ih,
--   { simp only [nth_commutator_zero, le_top], },
--   { simp only [nth_commutator_succ, map_commutator_eq_commutator_map, general_commutator_mono, *], }
-- end

-- variables {f}

-- lemma nth_commutator_le_map_nth_commutator (hf : function.surjective f) (n : ℕ) :
--   nth_commutator G' n ≤ (nth_commutator G n).map f :=
-- begin
--   induction n with n ih,
--   { rwa [nth_commutator_zero, nth_commutator_zero, top_le_iff, ← monoid_hom.range_eq_map,
--     ← monoid_hom.range_top_iff_surjective.mpr], },
--   { simp only [*, nth_commutator_succ, commutator_le_commutator_map], }
-- end

-- lemma nth_commutator_eq_map_nth_commutator (hf : function.surjective f) (n : ℕ) :
--   nth_commutator G' n = (nth_commutator G n).map f :=
-- le_antisymm (nth_commutator_le_map_nth_commutator hf n) (nth_commutator_map_le_nth_commutator f n)

-- lemma nth_commutator_lift_le_nth_commutator (H : subgroup G) (n : ℕ) :
--   (nth_commutator H n).lift ≤ nth_commutator G n :=
-- nth_commutator_map_le_nth_commutator _ n

-- end nth_commutator_map

-- section general_nth_commutator_map

-- variables (f) (H : subgroup G)

-- lemma map_nth_commutator_eq_nth_commutator_map (n : ℕ) :
--   (general_nth_commutator H n).map f = general_nth_commutator (H.map f) n :=
-- begin
--   induction n with n ih,
--   { simp only [general_nth_commutator_zero], },
--   { rw [general_nth_commutator_succ,general_nth_commutator_succ,
--     map_commutator_eq_commutator_map, ih], },
-- end

-- lemma lift_nth_commutator_eq_nth_commutator_lift (K : subgroup H) (n : ℕ) :
--   (general_nth_commutator K n).lift = general_nth_commutator K.lift n :=
-- map_nth_commutator_eq_nth_commutator_map _ _ _

-- lemma nth_commutator_lift_eq_general_nth_commutator (n : ℕ) :
--   (nth_commutator H n).lift = general_nth_commutator H n:=
-- begin
--   induction n with n ih,
--   { rw [nth_commutator_zero, general_nth_commutator_zero, lift_top], },
--   { rw [nth_commutator_succ, general_nth_commutator_succ,
--     lift_commutator_eq_commutator_lift_lift, ih], },
-- end

-- end general_nth_commutator_map

-- end commutator_map

-- end commutator

/-- The abelianization of G is the quotient of G by its commutator subgroup. -/
def abelianization : Type u :=
quotient_group.quotient (commutator G)

namespace abelianization

local attribute [instance] quotient_group.left_rel

instance : comm_group (abelianization G) :=
{ mul_comm := λ x y, quotient.induction_on₂' x y $ λ a b,
  begin
    apply quotient.sound,
    apply subset_normal_closure,
    use b⁻¹, use a⁻¹,
    group,
  end,
.. quotient_group.quotient.group _ }

instance : inhabited (abelianization G) := ⟨1⟩

variable {G}

/-- `of` is the canonical projection from G to its abelianization. -/
def of : G →* abelianization G :=
{ to_fun := quotient_group.mk,
  map_one' := rfl,
  map_mul' := λ x y, rfl }

section lift
-- So far we have built Gᵃᵇ and proved it's an abelian group.
-- Furthremore we defined the canonical projection `of : G → Gᵃᵇ`

-- Let `A` be an abelian group and let `f` be a group homomorphism from `G` to `A`.
variables {A : Type v} [comm_group A] (f : G →* A)

lemma commutator_subset_ker : commutator G ≤ f.ker :=
begin
  apply normal_closure_le_normal,
  rintros x ⟨p, q, rfl⟩,
  simp [monoid_hom.mem_ker, mul_right_comm (f p) (f q)],
end

/-- If `f : G → A` is a group homomorphism to an abelian group, then `lift f` is the unique map from
  the abelianization of a `G` to `A` that factors through `f`. -/
def lift : (G →* A) ≃ (abelianization G →* A) :=
{ to_fun := λ f, quotient_group.lift _ f (λ x h, f.mem_ker.2 $ commutator_subset_ker _ h),
  inv_fun := λ F, F.comp of,
  left_inv := λ f, monoid_hom.ext $ λ x, rfl,
  right_inv := λ F, monoid_hom.ext $ λ x, quotient_group.induction_on x $ λ z, rfl }

@[simp] lemma lift.of (x : G) : lift f (of x) = f x :=
rfl

theorem lift.unique
  (φ : abelianization G →* A)
  -- hφ : φ agrees with f on the image of G in Gᵃᵇ
  (hφ : ∀ (x : G), φ (of x) = f x)
  {x : abelianization G} :
  φ x = lift f x :=
quotient_group.induction_on x hφ

end lift

variables {A : Type v} [monoid A]

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem hom_ext (φ ψ : abelianization G →* A)
  (h : φ.comp of = ψ.comp of) : φ = ψ :=
monoid_hom.ext $ λ x, quotient_group.induction_on x $ monoid_hom.congr_fun h

end abelianization

-- section solvable

-- def is_solvable : Prop := ∃ n : ℕ, nth_commutator G n = (⊥ : subgroup G)

-- lemma is_solvable_of_comm {G : Type*} [comm_group G] : is_solvable G :=
-- begin
--   use 1,
--   rw [eq_bot_iff, nth_commutator_one],
--   calc commutator G ≤ (monoid_hom.id G).ker : abelianization.commutator_subset_ker (monoid_hom.id G)
--   ... = ⊥ : rfl,
-- end

-- lemma is_solvable_of_top_eq_bot (h : (⊤ : subgroup G) = ⊥) : is_solvable G :=
-- ⟨0, by simp *⟩

-- variables {G} {G' : Type*} [group G'] {f : G →* G'}

-- lemma solvable_of_solvable_injective (hf : function.injective f) (h : is_solvable G') :
--   is_solvable G :=
-- begin
--   cases h with n hn,
--   use n,
--   rw eq_bot_iff_map_eq_bot hf,
--   rw eq_bot_iff at *,
--   calc map f (nth_commutator G n) ≤ nth_commutator G' n : nth_commutator_map_le_nth_commutator f n
--   ... ≤ ⊥ : hn,
-- end

-- lemma subgroup_solvable_of_solvable (H : subgroup G) (h : is_solvable G) : is_solvable H :=
-- solvable_of_solvable_injective (show function.injective (subtype H), by ext) h

-- lemma solvable_image_of_solvable (hf : function.surjective f) (h : is_solvable G) :
--   is_solvable G' :=
-- begin
--   cases h with n hn,
--   use n,
--   calc nth_commutator G' n = (nth_commutator G n).map f : nth_commutator_eq_map_nth_commutator hf n
--     ... = (⊥ : subgroup G).map f : by rw hn
--     ... = ⊥ : map_bot f,
-- end

-- lemma solvable_quotient_of_solvable (H : subgroup G) [H.normal] (h : is_solvable G) :
--   is_solvable (quotient_group.quotient H) :=
-- solvable_image_of_solvable (show function.surjective (quotient_group.mk' H), by tidy) h

-- open quotient_group

-- --this theorem (and its proof) is due to Mario

-- theorem eq_top_of_trivial_quotient (N:subgroup G) [N.normal]
--   (H : (⊤ : subgroup (quotient_group.quotient N)) ≤ ⊥) : N = ⊤ :=
-- begin
--   rw [← ker_mk N, eq_top_iff, monoid_hom.ker, ← subgroup.map_le_iff_le_comap],
--   exact le_trans le_top H,
-- end

-- --(ker_mk N).symm.trans $ eq_top_iff.2 $ subgroup.map_le_iff_le_comap.1 $ le_trans le_top H

-- lemma le_ker {G' : Type*} [group G'] (f : G →* G') {H : subgroup G} : H.map f ≤ ⊥ ↔ H ≤ f.ker :=
-- begin
--   split,
--   { intros h x hx,
--     rw [← eq_bot_iff, eq_bot_iff_forall] at h,
--     exact (monoid_hom.mem_ker f).mpr (h (f x) ⟨x, hx, rfl⟩), },
--   { rintros h _ ⟨x, hx, rfl⟩,
--     exact mem_bot.mpr ((monoid_hom.mem_ker f).mp (h hx)), },
-- end

-- lemma nth_commutator_le_ker {G' : Type*} [group G'] (f : G →* G') (h : is_solvable G') :
--   ∃ n, nth_commutator G n ≤ f.ker :=
-- begin
--   cases h with n hn,
--   have key := nth_commutator_map_le_nth_commutator f n,
--   exact ⟨n, by rwa [hn, le_ker] at key⟩,
-- end

-- lemma nth_commutator_le_of_solvable_quotient (H : subgroup G) [H.normal]
--   (h : is_solvable (quotient_group.quotient H)) : ∃ n, (nth_commutator G n) ≤ H :=
-- by {rw ← ker_mk H, exact nth_commutator_le_ker (mk' H) h}

-- lemma nth_commutator_le_map_nth_commutator_of_le_map {G' : Type*} [group G'] {f : G →* G'}
--   {H : subgroup G} {K : subgroup G'} (h : K ≤ H.map f) (n : ℕ) :
--   general_nth_commutator K n ≤ (general_nth_commutator H n).map f :=
-- calc general_nth_commutator K n
--       ≤ general_nth_commutator (map f H) n : general_nth_commutator_mono _ _ h n
--   ... = (general_nth_commutator H n).map f : by rw ← map_nth_commutator_eq_nth_commutator_map

-- lemma short_exact_sequence_solvable' {G' G'' : Type*} [group G'] [group G''] (f : G' →* G)
--   (g : G →* G'') (hfg : f.range = g.ker) (hG' : is_solvable G') (hG'' : is_solvable G'') :
--   is_solvable G :=
-- begin
--   cases hG' with n hn,
--   obtain ⟨m, hm⟩ := nth_commutator_le_ker g hG'',
--   use n + m,
--   rw [eq_bot_iff, nth_commutator_eq_general_nth_commutator_top, additive_general_nth_commutator',
--     ← nth_commutator_eq_general_nth_commutator_top],
--   rw [← hfg, monoid_hom.range_eq_map] at hm,
--   calc general_nth_commutator (nth_commutator G m) n
--       ≤ (general_nth_commutator (⊤ : subgroup G') n).map f : nth_commutator_le_map_nth_commutator_of_le_map hm n
--   ... = (nth_commutator G' n).map f : by rw ← nth_commutator_eq_general_nth_commutator_top
--   ... = (⊥ : subgroup G').map f : by rw hn
--   ... = (⊥ : subgroup G) : map_bot f,
-- end

-- lemma range_subtype (H : subgroup G) : H.subtype.range = H :=
-- by { ext, exact ⟨λ ⟨⟨x, hx⟩, rfl⟩, hx, λ hx, ⟨⟨x, hx⟩, rfl⟩⟩ }

-- lemma short_exact_sequence_solvable'' (H : subgroup G) [H.normal] (h : is_solvable H)
--   (h' : is_solvable (quotient_group.quotient H)) : is_solvable G :=
-- begin
--   refine short_exact_sequence_solvable' (subtype H) (mk' H) _ h h',
--   rw [ker_mk, range_subtype],
-- end

-- lemma solvable_prod {G' : Type*} [group G'] (h : is_solvable G) (h' : is_solvable G') :
--   is_solvable (G × G') :=
-- begin
--   refine short_exact_sequence_solvable' (monoid_hom.inl G G') (monoid_hom.snd G G') _ h h',
--   ext x, split,
--   { rintros ⟨y, rfl⟩,
--     simp only [monoid_hom.mem_ker, monoid_hom.inl_apply, monoid_hom.coe_snd], },
--   { cases x with x y,
--     intros hx,
--     simp only [monoid_hom.mem_ker, monoid_hom.coe_snd] at hx,
--     simp only [monoid_hom.mem_range, monoid_hom.inl_apply, hx],
--     use x, }
-- end

-- lemma quotient_something (H : subgroup G) [H.normal]
--   (h' : is_solvable (quotient_group.quotient H)) : ∃ m : ℕ, (nth_commutator G m) ≤ H :=
-- begin
--   unfold is_solvable at h',
--   cases h' with paris france,
--   use paris,

--   have surj:function.surjective (quotient_group.mk' H),
--   convert surjective_quot_mk setoid.r,
--   have image: nth_commutator (quotient H) paris=(nth_commutator G paris).map (quotient_group.mk' H),
--   apply nth_commutator_eq_map_nth_commutator surj,
--   rw france at image,
--   suffices: ↑(nth_commutator G paris) ⊆ ↑H,
--   exact coe_subset_coe.mp this,
--   intros x x_in,

--   --it seems like this should follow from image in one line
--   have bound:(mk' H) x ∈ (⊥:subgroup (quotient H)),
--   simp *,
--   use x,
--   split,
--   exact x_in,
--   simp only [eq_self_iff_true],
--   have reduction:(mk' H) x=(mk' H) 1,
--   simp[bound],
--   exact mem_bot.mp bound,
--   rw  subgroup.set.has_coe,
--   have triv_mem':=subgroup.one_mem H,
--   have triv_mem: (1:G)∈ ↑ H,
--   exact mem_coe.mpr triv_mem',
--   have s:= @quotient_group.eq G _inst_1 H 1 x,
--   have small:1⁻¹ * x=x,
--   simp only [one_inv, one_mul],
--   rw small at s,
--   apply s.1,
--   have hmmmm:↑(1:G)=mk (1:G),
--   exact (rfl.congr bound).mp (eq.symm bound),
--   have hmmmmmmmm:↑ x=mk x,
--   exact (rfl.congr (eq.symm bound)).mp bound,
--   change (mk) x=(mk) 1 at reduction,
--   symmetry,
--   rwa [hmmmm,hmmmmmmmm],
-- end

-- lemma short_exact_sequence_solvable (H : subgroup G) [H.normal]
-- (h : is_solvable H) (h':is_solvable (quotient_group.quotient H)): is_solvable G:=
-- begin
--   have reduction:=quotient_something H h',
--   unfold is_solvable at h,
--   cases h with n n_solves,
--   cases reduction with m m_solves,
--   use n+m,
--   rw [nth_commutator_eq_general_nth_commutator_top, additive_general_nth_commutator'],
--   rw nth_commutator_eq_general_nth_commutator_top at m_solves,
--   rw nth_commutator_eq_general_nth_commutator_top at n_solves,
--   apply eq_bot_iff.mpr,

--   have s: general_nth_commutator H n≤ ⊥,

--   {rw ← nth_commutator_eq_general_nth_commutator_top at n_solves,
--   suffices t: (nth_commutator H n).lift = general_nth_commutator H n,
--   rw n_solves at t,
--   have v: (⊥:subgroup H).lift =⊥:=(⊥:subgroup H).eq_bot_iff_lift_eq_bot.mp rfl,
--   {rw v at t,
--   finish},
--   apply nth_commutator_lift_eq_general_nth_commutator},

--   suffices x:
--   general_nth_commutator (general_nth_commutator ⊤ m) n≤ general_nth_commutator H n,
--   finish,

--   apply general_nth_commutator_mono,
--   exact m_solves,
-- end


-- inductive weekday : Type
-- | monday : weekday
-- | tuesday : weekday
-- | wednesday : weekday
-- | thursday : weekday
-- | friday : weekday

-- lemma weekday_perm_unsolvable:¬ is_solvable (equiv.perm weekday):=
-- begin
--   unfold is_solvable,
--   push_neg,
--   --have stability:∀ n:ℕ,
--   --intro n,
--   --induction n,
--   --pply subgroup.eq_bot_iff_forall (nth_commutator (equiv.perm weekday) ),
--   sorry,

-- end

-- --nth_commutator_eq_map_nth_commutator

-- --def alternating_group (X:Type u)[fintype X]:Type u:=(equiv.perm.sign X).ker

-- --instance (X:Type u)[fintype X]: group((equiv.perm.sign X).ker)

-- lemma unsolvability_of_S_5 (X:Type u)(big:5≤ cardinal.mk X)[fintype X]:¬ is_solvable (equiv.perm X):=
-- begin
--   --have x:=X.elems.val.to_list,
--   unfold is_solvable,
--   push_neg,
--   have moscow:=_inst_3.elems,
--   have russia:=_inst_3.complete,
--   let delhi:=fintype.elems X,
--   let paris:=(delhi).val,
--   have france:=(delhi).nodup,
--   have u: list X,
--   exact list.nil,


--   rw cardinal.le_mk_iff_exists_set at big,
--   cases big with big_subset florida,
--   --have v:cardinal.mk big_subset < cardinal.omega,
--   --apply cardinal.lt_omega.2,
--   --use 5,

--   --exact florida,

--   --have u: fintype big_subset,
--   --apply fintype.of_equiv,
--   have w:fintype.card ↥big_subset=5,

--   --library_search,


--   have equiv: nonempty((fin 5)≃ big_subset),

--   apply fintype.card_eq.1,


--   --library_search!,
--   --have first: ∃ x_1,x_1∈ big_subset,
--   all_goals { sorry },
-- end

-- end solvable
